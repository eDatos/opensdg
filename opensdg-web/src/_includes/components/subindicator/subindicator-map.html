<script src="{{ site.baseurl }}/assets/js/node_modules/leaflet/dist/leaflet.css"></script>
<!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="{{ site.baseurl }}/assets/js/node_modules/leaflet/dist/leaflet.js"></script>
<script src="{{ site.baseurl }}/assets/js/node_modules/underscore/underscore-min.js"></script>
<script src="{{ site.baseurl }}/assets/js/node_modules/papaparse/papaparse.min.js"></script>
<script src="{{ site.baseurl }}/assets/js/node_modules/jquery/dist/jquery.min.js"></script>

{% assign subindicator = include.scope %}

{% assign show_data = false %}
{% if subindicator.reporting_status == "complete" and subindicator.data_non_statistical != true %}
{% assign show_data = true %}
{% endif %}

{% if show_data %}
<button class="btn btn-success" onclick="playMapAnimation()">Play</button>
<div class="personal-leaflet-map" style="height: 600px;  width: 600px;" id="mapid-{{ subindicator.slug }}"></div>
<script>
    // Funciones obtenidas de https://krazydad.com/tutorials/makecolors.php
    /**
     * Convierte un vector RGB codificado como un objeto {r:R, g:G, b:B} en un color hexadecimal.
     */
    function rgb2Hex(color) {
        return '#' + byte2Hex(color.r) + byte2Hex(color.g) + byte2Hex(color.b);
    }


    /**
     * Devuelve la representación en formato hexadecimal adaptado para CSS del número pasado.
     */
    function byte2Hex(n) {
        let nybHexString = "0123456789ABCDEF";
        return String(nybHexString.substr((n >> 4) & 0x0F, 1)) + nybHexString.substr(n & 0x0F, 1);
    }


    /**
     * Convierte de un color representado como un número hexadecimal a un color representado como
     * {r:R, g:G, b:B}
     */ 
    function hex2Rgb(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }


    /**
     * Realiza la interpolación entre los dos vectores que representan los colores de origen y destino del gradiente.
     */
    function lerp(origen, destino, aumento) {
        let auxVector = { r: 0, g: 0, b: 0 };
        if (aumento > 1.0) { aumento = 1.0 }; // Realizamos clamp del último valor para evitar errores de redondeo.
        auxVector.r = origen.r + (destino.r - origen.r) * aumento;
        auxVector.g = origen.g + (destino.g - origen.g) * aumento;
        auxVector.b = origen.b + (destino.b - origen.b) * aumento;

        return auxVector;
    }


    /**
     * Devuelve los datos requeridos del CSV en base al feature seleccionado.
     * @date 2021-04-12
     * @param {object} feature Polígono seleccionado
     * @param {object} csv     CSV de datos
     * @returns {float}
     */
    function getData(feature, csv) {
        let featureGeocode = feature['properties']['geocode'].toString();
        let rowData = _.findWhere(csv, { Geocode: featureGeocode });
        return rowData ? rowData["Value"] : null;
    }


    /**
     * Devuelve una matriz de clusters en base a un array de entrada y
     * a un número de clusters utilizando el método de las K-Medias.
     */
    function kmeans(arrayToProcess, Clusters) {
        var Groups = new Array();
        var Centroids = new Array();
        var oldCentroids = new Array();
        var changed = false;

        // initialise group arrays
        for (initGroups = 0; initGroups < Clusters; initGroups++) {
            Groups[initGroups] = new Array();
        }

        // pick initial centroids
        initialCentroids = Math.round(arrayToProcess.length / (Clusters + 1));
        for (i = 0; i < Clusters; i++) {
            Centroids[i] = arrayToProcess[(initialCentroids * (i + 1))];
        }

        do {
            for (j = 0; j < Clusters; j++) {
                Groups[j] = [];
            }
            changed = false;
            for (i = 0; i < arrayToProcess.length; i++) {
                Distance = -1;
                oldDistance = -1
                for (j = 0; j < Clusters; j++) {
                    distance = Math.abs(Centroids[j] - arrayToProcess[i]);
                    if (oldDistance == -1) {
                        oldDistance = distance;
                        newGroup = j;
                    } else if (distance <= oldDistance) {
                        newGroup = j;
                        oldDistance = distance;
                    }
                }
                Groups[newGroup].push(arrayToProcess[i]);
            }
            oldCentroids = Centroids;
            for (j = 0; j < Clusters; j++) {
                total = 0;
                newCentroid = 0;
                for (i = 0; i < Groups[j].length; i++) {
                    total += Groups[j][i];
                }
                newCentroid = total / Groups[newGroup].length;
                Centroids[j] = newCentroid;
            }

            for (j = 0; j < Clusters; j++) {
                if (Centroids[j] != oldCentroids[j]) {
                    changed = true;
                }
            }
        }
        while (changed == true);
        return Groups;
    }


    /**
     * Devuelve un color en formato {r:R, g:G, b:B} a partir de una cadena de texto
     * con formato "R,G,B"
     */
    function getColorObjectFromString(colorString) {
        let colorStringSplited = colorString.split(',');
        return {
            r: parseInt(colorStringSplited[0]),
            g: parseInt(colorStringSplited[1]),
            b: parseInt(colorStringSplited[2])
        }
    }


    /**
     * Devuelve un array con los colores disponibles en formato hexadecimal en base al gradiente de colores seleccionado
     * @date 2021-04-12
     * @param {int} colorBins   Número de colores a generar
     * @param {object} baseColor   Color base del degradado
     * @param {object} endColor    Color final del degradado
     * @returns {array<string>}
     */
     function getColors(colorBins, baseColor, endColor) {
        // IDEA EDATOS-3320: Se podría generalizar para cualquier cantidad de colores de paso
        colorBins = colorBins - 1;
        let step = 1 / colorBins;
        let aumento = step;
        let colores = [rgb2Hex(baseColor)];
        for (let i = 0; i < colorBins; i++) {
            colores.push(rgb2Hex(lerp(baseColor, endColor, aumento)));
            aumento += step;
        }

        return colores;
    }


    /**
     * Devuelve el color que ha de tener un tile dependiendo del parámetro pasado y los datos existentes.
     */
    function getColor(d) {
        if (d == null) {
            return "#FFFFFF";
        }

        let colorBins = {{ subindicator.colorBins }};
        let colors = getColors(
            colorBins,
            getColorObjectFromString("{{ subindicator.base_color }}"),
            getColorObjectFromString("{{ subindicator.end_color }}")
        );

        for (let i = 0; i < colorBins; i++) {
            if (d >= clusters[i][0] && d <= clusters[i][1]) {
                return colors[i];
            }
        }
    }


    /**
     * Devuelve un array de fechas a patir del CSV pasado.
     * @date 2021-04-12
     * @param {Object} csv Objeto con la estructura CSV de los datos
     * @returns {Array<int>}
     */
    function getCSVDates(csv) {
        return _.uniq(_.map(csv, row => parseInt(row['Year']))).sort();
    }


    /**
     * Filtra el csv pasado para devolver solo los campos necesarios
     * @date 2021-04-12
     * @param {Object} csv  Objeto con la estructura CSV de los datos
     * @param {int} date    Fecha por la cual se van a filtrar los datos
     * @returns {Object}    El CSV filtrado por fecha
     */
    function getFilteredCSVByDate(csv, date) {
        let filteredCSV = _.filter(csv, row => parseInt(row['Year']) == date && row['Territorio'] === "{{ subindicator.territory_geocode }}");
        filteredCSV = _.map(filteredCSV, row => {
            row['Geocode'] = row['Geocode'].replaceAll("'", "");
            return row;
        })
        return filteredCSV;
    }


    /**
     * Calcula los clusters de datos utilizando el método de las K-Medias
     * @date 2021-04-12
     * @param {any} csvValues Valores obtenidos del CSV del subindicador
     * @param {any} colorBins Número de clusters que se han de crear. En este caso basado en el número de colores a mostrar.
     */
    function computeClusters(csvValues, colorBins) {
        // IDEA EDATOS-3320: Generalizar esto para poder utilizar cualquier algoritmo de clustering.
        clusters = kmeans(csvValues, colorBins); 
        // Creamos pares de mínimo y máximo en cada cluster para agilizar la posterior búsqueda
        clusters = _.map(clusters, cluster => {
            if (cluster.length > 1) {
                return [_.min(cluster), _.max(cluster)];
            } else {
                // IDEA: Usar como máximo cluster[0] + 1 para asegurarnos de tener un rango.
                return [cluster[0], cluster[0]];
            }
        });
        // Ordenamos los clusters por valores de menor a mayor.
        clusters = _.sortBy(clusters, arr => arr[0]);
    }

    
    /**
     * Pone en marcha la animación para ver la evolución de los datos a lo largo del tiempo.
     * @date 2021-04-12
     */
    function playMapAnimation() {
        getPlayPromise(2).then(function () { console.log("FIN") });
    }
    

    /**
     * Devuelve una promesa para la animación de las capas
     * @date 2021-04-12
     * @param {int} stepDuration Duración de cada transición en segundos
     * @returns {Promise}
     */
    function getPlayPromise(stepDuration) {
        return new Promise(function (resolve, reject) {
            let promises = [];
            let step = 0;
            for (let date of dates) {
                promises.push(new Promise(resolver => setTimeout(() => {
                    currentDate = date;
                    mymap.eachLayer(layer => {
                        // Evitamos operar sobre capas sin feature
                        if (layer.feature) {
                            // IDEA EDATOS-3320: Interpolar los colores para crear una transición suave entre ellos.
                            let filteredCSV = getFilteredCSVByDate(csvObj, date);
                            let data = getData(layer.feature, filteredCSV);
                            layer.setStyle(
                                {
                                    fillColor: getColor(data),
                                    fillOpacity: data != null ? 0.9 : 0,
                                    weight: 2,
                                    opacitg: 1
                                }
                            )
                        }
                    });
                }, stepDuration * 1000 * step)));
                step += 1;
            }
            promises.reduce((p,x) => p.then(), Promise.resolve)
        });
    }


    // Se definen las variables de scope global.
    var geojsonObj;
    var csvObj;
    var clusters;
    var currentDate;
    var dates;

    var mymap = L.map('mapid-{{ subindicator.slug }}').setView([28.3646656, -16.1124336], 7);

    // TODO EDATOS-3320: Extraer algunos de estos datos del archivo de configuración {{ site.accessToken }} por ejemplo.
    L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}', {
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
        maxZoom: 18,
        id: 'mapbox/streets-v11',
        tileSize: 512,
        zoomOffset: -1,
        accessToken: 'pk.eyJ1IjoianJvZGNvciIsImEiOiJja240bjEwdjMwa3EwMnZvMDdjejF6MXQ3In0.rwgQT9lyjU77AT7fSJD2vw'
    }).addTo(mymap);

    let geojsonURL = "{{ subindicator.geojson }}";
    let csvURL = "{{ page.remote_data_prefix }}/data/{{ subindicator.slug }}.csv";
    fetch(geojsonURL)
        .then(res => res.json())
        .then(json => {
            geojsonObj = json;
            fetch(csvURL)
                .then(csv_res => csv_res.text())
                .then(csv_text => {
                    let csv = Papa.parse(csv_text, { header: true }).data;
                    // Eliminadmos las líneas del csv que no tengan Geocode.
                    csv = csvObj = _.filter(csv, row => row['Geocode'] != undefined && row['Geocode'] !== "");
                    dates = getCSVDates(csv);
                    currentDate = _.min(dates);

                    let filteredCSV = getFilteredCSVByDate(csv, currentDate);
                    let csvValues = _.map(csv, row => parseFloat(row["Value"], 10));
                    computeClusters(csvValues, 10);
                    
                    json['features'].forEach(feature => {
                        let data = getData(feature, filteredCSV);
                        L.geoJSON(feature, {
                            style: {
                                fillColor: getColor(data),
                                fillOpacity: data != null ? 0.9 : 0,
                                weight: 2,
                                opacitg: 1
                            }
                        }).addTo(mymap)
                    });
                })
        });
</script>
{% endif %}